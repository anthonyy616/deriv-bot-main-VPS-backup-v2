# PROJECT CONTEXT â€” INFINITE GRID + PAIR-LOCAL HEDGE STRATEGY (MT5)

**AUTHORITATIVE SPECIFICATION â€” V3.0**
No assumptions. No gaps. No contradictions.

---

## Implementation Progress

| Phase | Status | Files |
|-------|--------|-------|
| **Phase 1: Data Models & Persistence** | âœ… Complete | `core/models.py`, `db/schema.sql`, `core/persistence/repository.py` |
|âœ… **Phase 2: Strategy Engine + MT5 Bridge** â€” Complete (Corrected Strict)
   - **MT5 Authority**: MT5 is the sole truth. `on_external_tick` validates against `bridge.get_tick`.
   - **Strict Surface**: `MT5Bridge` exposes ONLY `initialize`, `shutdown`, `get_tick`, `execute_market_order`, `close_position`, `get_positions`, `get_deals_since`. NO dicts.
   - **Tick Contract**: Strict deduplication (bid/ask equality check) and monotonicity (time_msc check).
   - **Persistence**: No execution = No persistence. Checkpoints saved only if tick flows through validation.
   - **Failure Modes**: MT5 disconnect/failure aborts tick immediately without side effects./`
| Phase 3: Core Grid Engine | ðŸ”² Pending | `core/engine/pair_engine.py`, `core/engine/hedge_engine.py`, `core/engine/symbol_engine.py` |
| Phase 4: Invariant Checker | ðŸ”² Pending | `core/invariants/checker.py` |
| Phase 5: Recovery & Reconciliation | ðŸ”² Pending | `core/recovery/reconciler.py` |
| Phase 6: Testing | ðŸ”² Pending | `tests/` |

---

## 1. System Purpose

This system is an **infinite, geometry-driven grid trading engine** for MT5 synthetic indices (FX & SFX Volatility pairs only).
The system must operate **indefinitely** on a VPS without logic degradation, restart inconsistencies, or exposure leaks.

The strategy is:
- **Pair-based**: Each pair is an independent FSM
- **Threshold-driven**: Only price crossing triggers execution
- **Restart-safe**: State survives VPS restarts
- **Deterministic**: Same inputs = same outputs, always
- **Non-degrading**: 10,000th execution behaves identically to the 1st

---

## 2. Core Definitions

### Pip Definition (Non-Negotiable)

```
price = 100000.01
+1 pip  = 100001.01
+10 pips = 100010.01
+50 pips = 100050.01
```

All distance calculations MUST use this definition.

---

## 3. Grid Geometry (Infinite, Bidirectional)

### Grid Distance Configuration

```
pip_size = 1.0  # Base pip value (symbol-specific)
grid_distance_in_pips = CONFIG VALUE (from user settings)

effective_distance = grid_distance_in_pips Ã— pip_size
```

**CRITICAL DISTINCTIONS:**
- Grid distance is **USER-DEFINED** in pips (not from MT5 spread)
- MT5 spread is used for **ALIGNMENT ONLY** (initial anchor), NOT for grid spacing
- effective_distance is **LOCKED** per symbol session after initial calculation
- Persisted to SQLite
- Never recomputed mid-session

### Pair Indexing (Bidirectional)

For all integers `n âˆˆ â„¤` (negative, zero, positive):

```
B[n] = B[0] + n Ã— effective_distance
S[n] = B[nâˆ’1]
```

**INVARIANT:** `S[n] == B[n-1]` holds across ALL pairs indefinitely.
**INVARIANT:** `max_pairs` does NOT cap execution â€” grid is infinite.

**Examples:**
```
grid_distance_in_pips = 10
pip_size = 1.0
effective_distance = 10.0
B[0] = 100000

Positive direction:
  B[0] = 100000,  S[0] = 99990
  B[1] = 100010,  S[1] = 100000 (== B[0])
  B[2] = 100020,  S[2] = 100010 (== B[1])

Negative direction:
  B[-1] = 99990,  S[-1] = 99980
  B[-2] = 99980,  S[-2] = 99970
```

- No maximum pair index
- Negative indices are valid
- Pairs created lazily when price reaches their thresholds
- Grid expands infinitely in both directions

---

## 4. Fresh Grid Initialization vs Reopen (CRITICAL DISTINCTION)

### B0 Definition

```
B0 is always the FIRST DEFINED LEVEL (anchor point)
B0 is NOT always the first EXECUTED order after reset
```

### Fresh Grid Initialization (Empty Grid Only)

Triggers:
- `/start` command on empty grid
- Nuclear reset
- VPS restart with empty exposure

**Sequence:**
1. **B0 executes immediately as market BUY**
2. S0 is armed at `B0 âˆ’ effective_distance`

**HARD RULE**: S0 can never execute before B0 on an empty grid.

### After Reset (Reopen Scenario)

- First execution depends on current price vs B0/S0 (see Section 11)
- Buy may be limit or stop
- Sell may execute first in some scenarios
- B0 remains the ANCHOR, not necessarily the first trade

---

## 5. Execution Model (Threshold-Based Only)

### Trigger Condition

- **Only threshold crossing triggers execution**
- Zone containment is NEVER used
- No time-based triggers

### Same-Tick Multi-Pair Execution

If a single tick crosses multiple thresholds:

| Rule | Specification |
|------|--------------|
| Execution scope | ALL crossed levels execute in the SAME event cycle |
| Ordering | By distance from previous tick price (closest first) |
| Rate limiting | NONE â€” no throttling |
| Tick throttling | NONE |
| Determinism | Same tick delta = same execution sequence, always |

### Price Gap Handling

When price gaps across multiple levels:

1. Detect ALL levels crossed between previous_tick and current_tick
2. Sort by distance from previous_tick price
3. Execute each in order
4. Chain propagation after each execution
5. No skipping, no batching

---

## 6. Structural Chain Execution (Mandatory, Bidirectional)

Execution propagates structurally in BOTH directions:

| Execution | Creates | Reason |
|-----------|---------|--------|
| B[n] executes | S[n+1] must exist | Upward propagation |
| S[n] executes | B[n-1] must exist | Downward propagation |

**Both directions must be enforced. This is not optional.**

Propagation continues until grid invariants are satisfied.

**INVARIANT**: Chain propagation applies equally to:
- Normal threshold execution
- Reopening after reset
- Recovery re-arming

There is no "reopen mode" â€” all executions flow through identical logic.

---

## 7. Toggle Logic (Per Pair)

Each pair has an independent toggle:

```
BUY â†’ SELL â†’ BUY â†’ SELL â†’ â€¦
```

- Lot sizes follow UI order
- Toggle resets only on nuclear reset
- Toggle never skips

---

## 8. Max Positions (Per Pair)

- Each pair has `max_positions` (from config)
- When `trade_count == max_positions`:
  - Pair is **frozen** (no further grid trades)
  - **Hedge becomes eligible** (see Section 9)
  - Other pairs continue unaffected

---

## 9. Hedge System (Per Pair, Mandatory)

### Hedge Eligibility

Hedge becomes eligible **only** when:
```
trade_count == max_positions
```

### Hedge Direction (CRITICAL INVARIANT)

```
Hedge direction = INVERSE of the LAST EXECUTED POSITION that caused max_positions

- Last position was BUY  â†’ Hedge is SELL
- Last position was SELL â†’ Hedge is BUY
```

**DO NOT:**
- Infer net exposure
- Infer dominant side
- Use any logic other than "inverse of last executed position"

### Hedge Execution Mode

**IMMEDIATE ONLY** â€” There is no distance-based mode.

- Hedge is a **market order**
- Executed on the **next tick** after max_positions reached (to avoid race conditions)
- No pending orders
- No trigger prices

### Hedge Lot Size

- Configured per symbol via UI
- Field: `hedge_lot_size`
- Applied directly to market order

### Hedge Lifecycle

1. Hedge opens immediately after pair reaches max_positions
2. Hedge remains open while pair is frozen
3. Hedge closes **only** on:
   - TP hit
   - SL hit
   - Nuclear reset
4. Hedge closes **simultaneously** with pair positions (atomic)
5. **If user manually closes hedge** â†’ Re-open immediately (next tick market order)

### Hedge Invariants (All Mandatory)

| ID | Invariant |
|----|-----------|
| HEDGE-01 | One hedge per pair maximum (singleton) |
| HEDGE-02 | Hedge only exists when trade_count == max_positions |
| HEDGE-03 | Hedge direction = inverse of last executed position |
| HEDGE-04 | Hedge must always exist after max_positions reached |
| HEDGE-05 | Hedge must re-open after nuclear reset IF max is reached again |
| HEDGE-06 | Hedge must NOT persist across pair reset without requalification |
| HEDGE-07 | Hedge never increments trade_count |
| HEDGE-08 | If manually closed â†’ re-open immediately (next tick) |

---

## 10. TP/SL & Nuclear Reset (Pair-Local)

### When TP or SL hits for a pair:

1. All grid positions for that pair close
2. Hedge closes **simultaneously** (atomic)
3. Pair state resets to empty (trade_count=0, toggle=BUY)
4. Grid structure (price levels) remains intact

This is a **single atomic state transition**.

### Partial Fill Handling

If MT5 closes some but not all positions:
1. Forced reconciliation with MT5
2. Attempt to close remaining positions
3. If still inconsistent â†’ nuclear reset for that pair
4. **Never halt indefinitely** â€” system must self-heal

---

## 11. Reopening After Reset (Critical Logic)

After reset, reopening must:
- Use **same exact price levels**
- Determine order type dynamically
- Re-enter normal execution pipeline (no special mode)

### Order Type Rules

| Condition | First Order | Second Order |
|-----------|-------------|--------------|
| `Price > B[n]` | Buy Limit @ B[n] | Sell Stop @ S[n] |
| `Price < S[n]` | Sell Limit @ S[n] | Buy Stop @ B[n] |
| `S[n] < Price < B[n]` | Side of last closed trade | Opposite |

Where:
- B[n] = buy level of the pair
- S[n] = sell level of the pair
- Price = current price

**Priority for multi-pair reopen:**
- Ordered by distance from current price (closest first)
- Deterministic ordering (same price = same order)

**INVARIANT**: Reopening can trigger chain propagation to other pairs.
**INVARIANT**: Reopening is idempotent (same state = same result).

---

## 12. MT5 Architecture

### Connection Model

- **Single shared MT5 connection** for entire application
- **MT5 bridge lives INSIDE the strategy engine** (not external service)
- **Zero IPC latency** â€” no async boundary
- Centralized execution gateway for thread-safety

### Execution Gateway Responsibilities

- Send orders (market, limit, stop)
- Modify/cancel orders
- Query open positions
- Query deal history
- **All calls are sequenced** (no parallel order sends)

### Symbol Engine Isolation

- One symbol engine per active symbol
- Engines are pure decision units
- Engines do not own the MT5 connection
- Engines issue commands to execution gateway

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Strategy Engine                    â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚              MT5 Bridge (EMBEDDED)            â”‚  â”‚
â”‚  â”‚  - Zero IPC latency                          â”‚  â”‚
â”‚  â”‚  - No async boundary                         â”‚  â”‚
â”‚  â”‚  - Single-threaded sequenced execution       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                       â–²                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ Symbol    â”‚  â”‚ Symbol    â”‚  â”‚ Symbol    â”‚       â”‚
â”‚  â”‚ Engine 1  â”‚  â”‚ Engine 2  â”‚  â”‚ Engine N  â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 13. Persistence & Recovery

### Storage: SQLite (ACID, crash-safe)

### Persisted State

| Data | Purpose |
|------|---------|
| Pair states | buy_price, sell_price, trade_count, toggle, frozen |
| Effective distance | Locked per symbol session |
| Hedge state | status, direction, ticket, last_executed_type |
| Position map | ticket â†’ pair_id mapping |
| Last tick timestamp | Recovery checkpoint |
| First buy/sell prices | Per cycle, for reference |

### Restart Recovery Algorithm

1. Load SQLite state
2. Query MT5:
   - Open positions
   - Pending orders
   - Deals since last timestamp
3. Reconcile (MT5 = execution authority):
   - MT5 shows close, local shows open â†’ Apply reset
   - MT5 shows open, local shows closed â†’ Reconstruct from MT5
   - Position count mismatch â†’ Rebuild from MT5
4. Rebuild grid geometry from anchors
5. Re-arm virtual thresholds
6. Verify reopening is idempotent

**System must self-heal without manual intervention.**

---

## 14. Event Ordering Guarantees

```
1. Tick received
2. Threshold crossings detected (all levels)
3. Crossings sorted by distance from previous price
4. For each crossing (in order):
   a. Execute trade
   b. Update pair state
   c. Create companion pair (immediate)
   d. Check hedge eligibility
   e. Execute hedge if eligible
5. Check for MT5 closures (TP/SL)
6. Handle resets atomically
7. Verify all invariants
8. Persist checkpoint
```

---

## 15. Non-Degradation Guarantee

- No time-based logic
- No "first time" flags
- No counters tied to uptime
- Geometry-only decisions
- Idempotent reopening

The 10,000th execution behaves exactly like the first.

---

## 16. Invariants (Fatal on Violation)

### Core Grid Invariants
| ID | Invariant |
|----|-----------|
| INV-01 | `trade_count <= max_positions` |
| INV-02 | `S[n] == B[n-1]` for all n (grid geometry) |
| INV-03 | Grid extends bidirectionally (negative indices valid) |
| INV-04 | Companion creation immediate on execution |
| INV-05 | B0 first on empty grid (not after reset) |
| INV-06 | Effective distance immutable per symbol session |

### Hedge Invariants
| ID | Invariant |
|----|-----------|
| INV-07 | One hedge per pair maximum |
| INV-08 | Hedge only after max_positions |
| INV-09 | Hedge direction = inverse of last executed position |
| INV-10 | Hedge never increments trade_count |

### Execution Invariants
| ID | Invariant |
|----|-----------|
| INV-11 | Atomic TP/SL closure (hedge + grid simultaneous) |
| INV-12 | Same-tick multi-execution ordered deterministically |
| INV-13 | Reopen order-type follows price vs level rules |
| INV-14 | Reopening is idempotent (same state = same result) |

### Non-Degradation Invariants
| ID | Invariant |
|----|-----------|
| INV-15 | No time-based logic anywhere |
| INV-16 | 10,000th reopen == 1st reopen behavior |

---

## 17. File Structure

```
core/
â”œâ”€â”€ models.py                # Data models
â”œâ”€â”€ strategy_engine.py       # Main facade with embedded MT5 bridge
â”œâ”€â”€ engine/
â”‚   â”œâ”€â”€ symbol_engine.py     # Per-symbol event loop
â”‚   â”œâ”€â”€ pair_engine.py       # Grid FSM (bidirectional)
â”‚   â””â”€â”€ hedge_engine.py      # Hedge overlay controller
â”œâ”€â”€ persistence/
â”‚   â””â”€â”€ repository.py        # SQLite CRUD
â”œâ”€â”€ recovery/
â”‚   â””â”€â”€ reconciler.py        # MT5 state reconciliation
â”œâ”€â”€ invariants/
â”‚   â””â”€â”€ checker.py           # 16 invariant checks
â””â”€â”€ [existing files]

db/
â”œâ”€â”€ schema.sql               # SQLite schema
â””â”€â”€ grid_*.db                # Runtime generated
```

**No file outside `engine/` may contain strategy logic.**

---

## 18. Agent Boundaries

You are **NOT ALLOWED** to:
- Simplify logic
- "Optimize" execution order
- Change event ordering
- Infer missing rules
- Add time-based logic

You **MUST**:
- Follow this context verbatim
- Stop and ask when unclear
- Never assume trader intent
- Ensure zero silent failure paths

---

## 19. Phoenix Re-Open System (Zero-State Reset)

### Purpose

The Phoenix System ensures that a re-opened pair after TP/SL is **mathematically identical** to a fresh pair. It uses a **Destroy & Recreate** pattern instead of manual field resets.

### The Problem with Manual Resets

Manual field resets risk keeping stale flags:
- `hedge_active` might remain True
- `buy_in_zone` / `sell_in_zone` might have incorrect values
- Other flags could persist and cause logic bugs

### Phoenix Protocol

When a position closes (TP/SL):

1. **IDENTIFY**: Which pair index just closed?
2. **DETERMINE POLARITY**:
   - If a **BUY** position closed â†’ new start direction is **BUY**
   - If a **SELL** position closed â†’ new start direction is **SELL**
   - (Direction follows closed deal, NOT pair's default polarity)
3. **CLOSE HEDGE**: If hedge is active, close it first
4. **DESTROY**: `del self.pairs[N]` (Remove old object entirely)
5. **RECREATE**: Instantiate fresh `GridPair` at exact same price levels
6. **INITIALIZE**: Apply re-open invariants:
   - `trade_count = 0` (Forces Lot Size Index 0 â†’ 0.01)
   - `next_action` = Direction determined in Step 2
   - `is_reopened = True` (Bypasses zone latch logic)
   - `hedge_active = False`
   - `buy_filled = False`, `sell_filled = False`
   - `buy_in_zone = False`, `sell_in_zone = False`

### Implementation Methods

| Method | Location | Purpose |
|--------|----------|---------|
| `_phoenix_reset_pair(pair_index, start_direction)` | `symbol_engine.py` | Destroys old pair, creates fresh one |
| `_check_tp_sl_from_history()` | `symbol_engine.py` | Detects TP/SL, calls Phoenix reset |

### Phoenix Invariants

| ID | Invariant |
|----|-----------|
| PHOENIX-01 | Post-reset `trade_count` MUST be 0 |
| PHOENIX-02 | Post-reset `is_reopened` MUST be True |
| PHOENIX-03 | Post-reset `hedge_active` MUST be False |
| PHOENIX-04 | Restart direction follows closed deal type (not pair polarity) |
| PHOENIX-05 | Price levels (`buy_price`, `sell_price`) MUST be preserved |

### Verification Checklist

1. **Lot Size Reset**: After TP hit, next trade MUST be 0.01 (Index 0)
2. **Lot Progression**: Trade after re-open must be 0.02 (Index 1)
3. **Hedge Clearing**: If hedge was active, new pair has `hedge_active = False`
4. **Direction Memory**: Direction determined by what closed, not pair polarity

---

## 20. Position Drop Detection (Nuclear Reset Trigger)

### Purpose

The Position Drop Detection system is the **PRIMARY** trigger for Nuclear Reset. It monitors position counts per pair and triggers reset when a decrease is detected.

### Why This Over TP/SL History

The MT5 `history_deals_get` approach is unreliable because:
- Deals may not return expected `DEAL_REASON_TP` codes
- Magic number filtering can fail
- Timing issues with history queries

Position Drop Detection catches ALL cases:
- TP closures
- SL closures
- Manual user closures
- Broker-side liquidations

### Implementation

| Component | Location | Purpose |
|-----------|----------|---------|
| `last_pair_counts` | `__init__` | Tracks position count per pair from previous tick |
| `_monitor_position_drops()` | `symbol_engine.py` | Compares counts, triggers reset on decrease |

### Detection Logic

```
For each known pair:
    IF old_count > 0 AND new_count < old_count:
        1. Close ALL remaining positions (kill survivors)
        2. Close hedge if active
        3. Phoenix reset with polarity-based direction
        4. Save state immediately
```

### Restart Direction (Polarity-Based)

| Pair Index | Restart Direction |
|------------|-------------------|
| Positive (> 0) | SELL |
| Zero or Negative (â‰¤ 0) | BUY |
