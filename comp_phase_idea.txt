INIT is successful so we created new B100 and S101 for group 1

Now for completed pairs:

moment position drop is received on a completed pair then do this:
#Remember position drop can only be received when a pair hits TP/SL.

position drop signal received on a completed pair (from the 1st completed pair in group 0 - no need to check if it is still. only check if the pair is completed doesn't matter what group it came from as it will always follow this format).

check :
    if the CMP (at that tick the signal was received) > S101 price #(init name - should be dynamic to adapt for different groups but im using S101 as an example)
        then place B101 to trigger immediately with the second lot index (lot index 1) - as both of them are for the same pair now i.e. pair 101
    then also place S102 to trigger immediately with the first lot index (lot index 0) - as it is the leg for next pair 102
    
    These two fire atomically because for the new group C =0 at this stage (once they both trigger then C =1 , completed pair is pair 101)
    else
        do nothing 


    same thing for if B100 #Obviously if the above is true so this condition will always fail
        if the CMP at that tick the signal was received < B100 price #(init name )
            then place S100 to trigger immediately with the second lot index (lot index 1) - as both of them are for the same pair now i.e. pair 100
            then also place B99 to trigger immediately with the first lot index (lot index 0) - as it is the leg for next pair 99

            These two fire atomically because for the new group C =0 at this stage (once they both trigger then C =1 , completed pair is pair 100)
        else
            do nothing


continue this process for all completed pairs that have position drop signal received (from the 2nd completed pair in group 0 - no need to check if it is still. only check if the pair is completed doesn't matter what group it came from as it will always follow this format)

and use the last pair created like for the next expansion leg we will use 
    if CMP > S102 price to fire B102 and S103 atomically
    Now (C=2 after both fire) - completed pairs are: 101 and 102

    and
    if CMP < B99 price to fire S99 and B98 atomically
    Now (C=2 after both fire) - completed pairs are: 100 and 99

Then now that C == 2 we have to fire non-atomically 
so if the signal for position drop for a complete pair (last one in group 0 is received - you dont have to confirm it's the last one in group 0 it will always be)
    if CMP > S103 
        fire ONLY B103 to trigger immediately with the second lot index (lot index 1) - as both of them are for the same pair now i.e. pair 103
    else
        do nothing

    if CMP < B98
        fire ONLY S98 to trigger immediately with the second lot index (lot index 1) - as both of them are for the same pair now i.e. pair 98
    else
        do nothing


Then if the incomplete pairs now hit TP and are verified with the original check we use to know if it hit TP then create another init but for group 2 (group 2 has the same exact behaviour as group 3...infinity)

Note: The toggle trigger logic should always still hit for completed pairs in any group with the correct lot size config in group 1 and the code has to be dynamic to adapt for any group possible no matter how long the bot is left running for so hardcoded variables like B100 or S101 for checks is wrong and will fail past group 1. The code should be adaptable for different groups



Done!

Cosmetic fix for accuracy and to minimize degradation and risk minimization of init not happening:

It was correctly implemented. 
But i think this current version might slightly degrade overtime because the design of this system is meant to be when the non-atomic leg fires, we are meant to be placing init too by design of how it will be configured. 
The TP of this system is always configured to 3x the grid distance value. As you can see i have been testing with spread 30 and TP 90. this has always been consistent. But now, I want to introduce something new - artificial Take Profits to execute init. You know when C=2 we fire non-atomically, well after doing that we then check IF the incomplete pair has hit TP (or if it's still open) - anyone that's easier to judge, then if it's true (i.e. incomplete pair still open ) we will then close the incomplete pair ourselves and ASSUME the incomplete pair has hit TP so that init fires almost at the same price as the non-atomic pair because once a position drop is detected for that incomplete pair and we run the check it will always return true so we will create init. So it's like an artificial TP hit for to make sure that the grid is consistent and we always init because 





To fix race condition




expand logic (both bullish and bearish)

    lock here 

        if group_id==0:
            C= self._count_completed_pairs_for_group(self.current_group)

            if C !=2;
                EXPAND Normally using grid distance and execute atomically

            if C==2:
                EXPAND Normally, execute non-atomic leg, then force the artificial TP to close the incomplete pair for group 1 -> then update C =3 and fire init for the next grop i.e. 1


        else
        
            group_id=self.current_group
            C=self._count_completed_pairs_for_group(group_id)

            if C !=2;
                EXPAND ONLY due to TP hit and execute atomically

            if C==2:
                execute non-atomic leg, then force the artificial TP to close the incomplete pair for group _id -> then update C =3 and fire init for the next grpup

                



